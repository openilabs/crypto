{
  "name": "bigint",
  "version": "0.4.2",
  "description": "Arbitrary-precision integer arithmetic using libgmp",
  "main": "./index.js",
  "repository": {
    "type": "git",
    "url": "http://github.com/substack/node-bigint.git"
  },
  "keywords": [
    "gmp",
    "libgmp",
    "big",
    "bignum",
    "bigint",
    "integer",
    "arithmetic",
    "precision"
  ],
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "devDependencies": {
    "tap": "~0.2.5",
    "put": "~0.0.6"
  },
  "license": "MIT/X11",
  "engine": {
    "node": ">=0.2.0"
  },
  "scripts": {
    "install": "node-gyp configure build",
    "test": "tap test/*.js"
  },
  "readme": "bigint\n======\n\nArbitrary precision integral arithmetic for node.js!\n\n[![build status](https://secure.travis-ci.org/substack/node-bigint.png)](http://travis-ci.org/substack/node-bigint)\n\nThis library wraps around [libgmp](http://gmplib.org/)'s\n[integer functions](http://gmplib.org/manual/Integer-Functions.html#Integer-Functions)\nto perform infinite-precision arithmetic.\n\nYou should also consider using\n[bignum](https://github.com/justmoon/node-bignum),\nwhich is based on the bigint api but uses openssl instead of libgmp,\nwhich you are more likely to already have on your system.\n\nexample\n=======\n\nsimple.js\n---------\n\n    var bigint = require('bigint');\n    \n    var b = bigint('782910138827292261791972728324982')\n        .sub('182373273283402171237474774728373')\n        .div(8)\n    ;\n    console.log(b);\n\n***\n    $ node simple.js\n    <BigInt 75067108192986261319312244199576>\n\nperfect.js\n----------\n\nGenerate the perfect numbers:\n\n    // If 2**n-1 is prime, then (2**n-1) * 2**(n-1) is perfect.\n    var bigint = require('bigint');\n\n    for (var n = 0; n < 100; n++) {\n        var p = bigint.pow(2, n).sub(1);\n        if (p.probPrime(50)) {\n            var perfect = p.mul(bigint.pow(2, n - 1));\n            console.log(perfect.toString());\n        }\n    }\n\n***\n\n    6\n    28\n    496\n    8128\n    33550336\n    8589869056\n    137438691328\n    2305843008139952128\n    2658455991569831744654692615953842176\n    191561942608236107294793378084303638130997321548169216\n\nmethods[0]\n==========\n\nbigint(n, base=10)\n------------------\n\nCreate a new `bigint` from `n` and a base. `n` can be a string, integer, or\nanother `bigint`.\n\nIf you pass in a string you can set the base that string is encoded in.\n\n.toString(base=10)\n------------------\n\nPrint out the `bigint` instance in the requested base as a string.\n\nbigint.fromBuffer(buf, opts)\n----------------------\n\nCreate a new `bigint` from a `Buffer`.\n\nThe default options are:\n    {\n        order : 'forward', // low-to-high indexed word ordering\n        endian : 'big',\n        size : 1, // number of bytes in each word\n    }\n\nNote that endian doesn't matter when size = 1.\n\nmethods[1]\n==========\n\nFor all of the instance methods below you can write either\n\n    bigint.method(x, y, z)\n\nor if x is a `bigint` instance``\n\n    x.method(y, z)\n\n.toNumber()\n-----------\n\nTurn a `bigint` into a `Number`. If the `bigint` is too big you'll lose\nprecision or you'll get Â±`Infinity`.\n\n.toBuffer(opts)\n-------------\n\nReturn a new `Buffer` with the data from the `bigint`.\n\nThe default options are:\n    {\n        order : 'forward', // low-to-high indexed word ordering\n        endian : 'big',\n        size : 1, // number of bytes in each word\n    }\n\nNote that endian doesn't matter when size = 1.\n\n.add(n)\n-------\n\nReturn a new `bigint` containing the instance value plus `n`.\n\n.sub(n)\n-------\n\nReturn a new `bigint` containing the instance value minus `n`.\n\n.mul(n)\n-------\n\nReturn a new `bigint` containing the instance value multiplied by `n`.\n\n.div(n)\n-------\n\nReturn a new `bigint` containing the instance value integrally divided by `n`.\n\n.abs()\n------\n\nReturn a new `bigint` with the absolute value of the instance.\n\n.neg()\n------\n\nReturn a new `bigint` with the negative of the instance value.\n\n.cmp(n)\n-------\n\nCompare the instance value to `n`. Return a positive integer if `> n`, a\nnegative integer if `< n`, and 0 if `== n`.\n\n.gt(n)\n------\n\nReturn a boolean: whether the instance value is greater than n (`> n`).\n\n.ge(n)\n------\n\nReturn a boolean: whether the instance value is greater than or equal to n\n(`>= n`).\n\n.eq(n)\n------\n\nReturn a boolean: whether the instance value is equal to n (`== n`).\n\n.lt(n)\n------\n\nReturn a boolean: whether the instance value is less than n (`< n`).\n\n.le(n)\n------\n\nReturn a boolean: whether the instance value is less than or equal to n\n(`<= n`).\n\n.and(n)\n-------\n\nReturn a new `bigint` with the instance value bitwise AND (&)-ed with `n`.\n\n.or(n)\n------\n\nReturn a new `bigint` with the instance value bitwise inclusive-OR (|)-ed with\n`n`.\n\n.xor(n)\n-------\n\nReturn a new `bigint` with the instance value bitwise exclusive-OR (^)-ed with\n`n`.\n\n.mod(n)\n-------\n\nReturn a new `bigint` with the instance value modulo `n`.\n\n`m`.\n.pow(n)\n-------\n\nReturn a new `bigint` with the instance value raised to the `n`th power.\n\n.powm(n, m)\n-----------\n\nReturn a new `bigint` with the instance value raised to the `n`th power modulo\n`m`.\n\n.invertm(m)\n-----------\n\nCompute the multiplicative inverse modulo `m`.\n\n.rand()\n-------\n.rand(upperBound)\n-----------------\n\nIf `upperBound` is supplied, return a random `bigint` between the instance value\nand `upperBound - 1`, inclusive.\n\nOtherwise, return a random `bigint` between 0 and the instance value - 1,\ninclusive.\n\n.probPrime()\n------------\n\nReturn whether the bigint is:\n\n* certainly prime (true)\n* probably prime ('maybe')\n* certainly composite (false)\n\nusing [mpz_probab_prime](http://gmplib.org/manual/Number-Theoretic-Functions.html).\n\n.nextPrime()\n------------\n\nReturn the next prime greater than `this` using\n[mpz_nextprime](http://gmplib.org/manual/Number-Theoretic-Functions.html).\n\n.sqrt()\n-------\n\nReturn a new `bigint` that is the square root.  This truncates.\n\n.root(n)\n--------\n\nReturn a new `bigint` that is the `nth` root.  This truncates.\n\n.shiftLeft(n)\n-------------\n\nReturn a new `bigint` that is the `2^n` multiple. Equivalent of the `<<`\noperator.\n\n.shiftRight(n)\n--------------\n\nReturn a new `bigint` of the value integer divided by\n`2^n`. Equivalent of the `>>` operator.\n\n.gcd(n)\n-------\n\nReturn the greatest common divisor of the current bigint with `n` as a new\nbigint.\n\n.bitLength()\n------------\n\nReturn the number of bits used to represent the current bigint as a javascript\nNumber.\n\ninstall\n=======\n\nYou'll need the libgmp source to compile this package. Under Debian-based systems,\n\n    sudo aptitude install libgmp3-dev\n\nOn a Mac with [Homebrew](https://github.com/mxcl/homebrew/),\n\n    brew install gmp\n\nAnd then install with [npm](http://npmjs.org):\n\n    npm install bigint\n",
  "readmeFilename": "README.markdown",
  "bugs": {
    "url": "https://github.com/substack/node-bigint/issues"
  },
  "_id": "bigint@0.4.2",
  "dist": {
    "shasum": "2efba54f439f0eece142aca9c97a93f2775e2dbb"
  },
  "_from": "bigint@0.4.2",
  "_resolved": "https://registry.npmjs.org/bigint/-/bigint-0.4.2.tgz"
}
