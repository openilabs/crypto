{
  "name": "jwcrypto",
  "version": "0.4.5",
  "dependencies": {
    "browserify": "1.13.5",
    "http-browserify": "0.1.1",
    "vows": "0.5.13",
    "optimist": "0.2.6",
    "uglify-js": "1.0.6",
    "bigint": "0.4.2"
  },
  "devDependencies": {
    "jshint": "2.1.10",
    "walk": "2.2.1"
  },
  "optionalDependencies": {
    "bigint": "0.4.2"
  },
  "scripts": {
    "postinstall": "node ./scripts/bundle.js",
    "test": "./node_modules/.bin/vows"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/mozilla/jwcrypto.git"
  },
  "main": "index.js",
  "bin": {
    "generate-keypair": "./bin/generate-keypair",
    "check-assertion": "./bin/check-assertion",
    "certify": "./bin/certify"
  },
  "readme": "JavaScript implementation of JSON Web Signatures and JSON Web Tokens, especially as needed by BrowserID.\n\n[![Build Status](https://secure.travis-ci.org/mozilla/jwcrypto.png)](http://travis-ci.org/mozilla/jwcrypto)\n\n- libs contains third-party libraries that need to be included. See\nlibs/dependencies.txt and libs/package.txt\n\n- This is written as CommonJS modules for node and\n  such. Browserify is used to bundle it all up.\n\nNOTE: this is written as future documentation of v0.2 APIs, which will not\nbe backwards compatible with v0.1.\n\nOverview\n===\n\nJSON Web Tokens (JWTs) look like:\n\n    eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9\n    .\n    eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt\n    cGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n    .\n    dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk\n\n(line breaks are for readability)\n\nJWTs are made up of three components, each base64url-encoded, joined by a period character. A JWT can be either a JWS (JSON Web Signature) or a JWE (JSON Web Encryption). In this library, we only consider JWS. Because JWT is effectively the abstract superclass of both JWS and JWE, we don't expose JWT APIs directly (as of v0.2.0). We simply expose a JWS API.\n\nWe use JWK (JSON Web Keys) to specify keys:\nhttp://tools.ietf.org/html/draft-ietf-jose-json-web-key-00\n\nWe use JWA (JSON Web Algorithms) to specify algorithms:\nhttp://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-00\n(we add algorithm \"DS\" to indicate DSA, with DS160 the standard DSA 1024/160.)\n\nUsage\n=====\n\n  1. ensure that `libgmp` is installed on your system (e.g. `apt-get install libgmp-dev`), it's required by [bigint](https://github.com/substack/node-bigint), upon which jwcrypto depends\n  2. npm install jwcrypto\n  3. in javascript: `require('jwcrypto')`\n\nBasic API\n=========\n\n    var jwcrypto = require(\"jwcrypto\");\n\n    // random number generation is taken care of automatically\n    // with auto-seeding that is optimized for server or browser\n    // setup\n\n    // more entropy can be added as follows\n    // this can be useful to incorporate server-provided entropy\n    // on clients that don't have any good entropy of their own\n    // entropy should be either a 32 bit int, an array of ints, or a string\n    jwcrypto.addEntropy(entropy);\n\n    // generate a key\n    // we use DSA, which is \"DS\" in JSON Web Algorithm parlance\n    // we use keysize 160, which has a specific interpretation based\n    // on the algorithm, in this case DSA 1024/160, standard DSA.\n    jwcrypto.generateKeypair({\n        algorithm: 'DS',\n        keysize: 160\n    }, function(err, keypair) {\n        // error in err?\n\n        // serialize the public key\n        console.log(keypair.publicKey.serialize());\n\n        // just the JSON object to embed in another structure\n        console.log(JSON.stringify({stuff: keypair.publicKey.toJSONObject()}));\n\n        // create and sign a JWS\n        var payload = {principal: {email: 'some@dude.domain'},\n                       pubkey: jwcrypto.loadPublicKey(publicKeyToCertify)};\n\n        jwcrypto.sign(payload, keypair.secretKey, function(err, jws) {\n           // error in err?\n\n           // serialize it\n           console.log(jws.toString());\n        });\n\n        // also, if loading a secret key from somewhere\n        var otherSecretKey = jwcrypto.loadSecretKey(storedSecretKey);\n\n        // verify it\n        jwcrypto.verify(signedObject, publicKey, function(err, payload) {\n          // if verification fails, then err tells you why\n          // if verification succeeds, err is null, and payload is\n          // the signed JS object.\n        });\n    });\n\nAssertions\n====\n\nSometimes the JSON object to sign should be a standard assertion with pre-defined fields.\n\n    var assertion = require(\"jwcrypto\").assertion;\n\n    // payload of the assertion\n    var payload = {principal: {email: 'some@dude.domain'}};\n\n    // add special fields which will be encoded properly\n    // payload cannot contain reserved fields\n    assertion.sign(payload, {issuer: \"foo.com\", expiresAt: new Date(new Date().valueOf() + 5000),\n                             issuedAt: new Date().valueOf(), audience: \"https://example.com\"},\n                      keypair.secretKey,\n                      function(err, signedAssertion) {\n       // a normal signedObject, much like above\n       // can be verified with jwcrypto.verify\n\n       // or verified specifically for jwt, with expiration verification\n       var now = new Date();\n       assertion.verify(signedObject, keypair.publicKey, now, function(err, payload, assertionParams) {\n          // payload is the original payload\n          // assertionParams contains issuedAt, expiresAt as dates\n          // and issuer and audience as strings.\n       });\n    });\n\nNote that timestamps (for `issuedAt` and `expiresAt`) are integers containing the standard JS milliseconds-since-epoch, or objects with methods named `.valueOf()` which will return such an integer. The assertion format currently serializes these integers verbatim; a future version may serialize them as seconds (instead of milliseconds) to conform with the JWT specifications.\n\nCerts\n=======\n\nSometimes the JSON objects to sign are certificates\n\n    var cert = require(\"jwcrypto\").cert;\n\n    var keyToCertify = keypairToCertify.publicKey;\n    var principal = {email: \"someone@example.com\"};\n\n    var assertionParams = {issuer: \"foo.com\", issuedAt: new Date(),\n                           expiresAt: new Date()};\n\n    // cert params, kid is optional, others are required\n    var certParams = {kid: \"key-2012-08-11\",\n                      publicKey: keyToCertify,\n                      principal: principal};\n\n    var additionalPayload = {};\n\n    // payload cannot contain reserved fields\n    cert.sign(certParams,\n              assertionParams, additionalPayload,\n              keypair.secretKey,\n              function(err, signedObject) {\n       // normal signedObject\n       // can be verified with jwcrypto.verify\n\n       // or verified specifically for certification\n       // include a date that is considered the \"now\"\n       cert.verify(signedObject, keypair.publicKey, now, function(err, payload, assertionParams, certParams) {\n          // the extra payload\n          // the assertionParams specifics\n          // the certParams include publicKey being certified, and principal bound to it.\n       });\n    });\n\n    // bundle a cert chain and an assertion\n    var bundle = cert.bundle([certs], assertion);\n\n    function getPK(issuer, next) {\n        // function to get a public key for an issuer\n    }\n\n    var now = new Date();\n\n    // verify just the chain of certs\n    cert.verifyChain([certs], now, getPK, function(err, certParamsArray) {\n       // err is an error or null\n       // if no error:\n       // certParamsArray is the array of individual cert params from each verification\n       // including specifically the publicKey and principal parameters\n    });\n\n    // verify a chain of certs and assertion\n    cert.verifyBundle(bundle, now, getPK, function(err, certParamsArray, payload, assertionParams) {\n       // err is an error or null\n       // if no error:\n       // certParamsArray is the array of individual cert params from each verification\n       // payload is the assertion payload, and assertionParams is the assertion params.\n    });\n\nVersioning\n====\n\nThe formats of public-keys, as well as the special payload parameters of assertions and certificates, will be versioned.\n\nNot indicating a version number in the serialized payload indicates\nthe alpha format in the BrowserID specification from June\n2012. Otherwise, a version number is required. The BrowserID Beta version number is <tt>2012.08.15</tt>.\n\nBy default, <tt>jwcrypto</tt> will use the latest format\nautomatically, and will parse any past format (unless that becomes\nimpossible, in which case we'll define behavior then.)\n\nThe version of the data format can be discovered as:\n\n     jwcrypto.DATA_FORMAT_VERSION\n\nIf one wishes to use <tt>jwcrypto</tt> with an older data format:\n\n     jwcrypto.setDataFormatVersion('2012.08.15');\n\nor, to use the pre-versioning format:\n\n     jwcrypto.setDataFormatVersion('');\n\nor, to go back to the library default:\n\n     jwcrypto.setDataFormatVersion();\n\n",
  "readmeFilename": "README.md",
  "description": "JavaScript implementation of JSON Web Signatures and JSON Web Tokens, especially as needed by BrowserID.",
  "bugs": {
    "url": "https://github.com/mozilla/jwcrypto/issues"
  },
  "_id": "jwcrypto@0.4.5",
  "dist": {
    "shasum": "4e9070b17371d7671d8d7aefa020a1b6c0a72d91"
  },
  "_from": "jwcrypto"
}
