{
  "name": "js-nacl",
  "version": "0.6.0",
  "description": "Emscripten-compiled Javascript version of NaCl, the Networking and Cryptography library.",
  "main": "lib/nacl_factory.js",
  "author": {
    "name": "Tony Garnock-Jones"
  },
  "keywords": [
    "encryption",
    "high-level",
    "crypto",
    "networking",
    "nacl"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/tonyg/js-nacl.git"
  },
  "engines": {
    "node": "*"
  },
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha --ui exports test"
  },
  "devDependencies": {
    "mocha": ""
  },
  "readme": "# js-nacl: Pure-Javascript Emscripten-compiled NaCl routines\n\n[Emscripten](https://github.com/kripken/emscripten)-compiled\n[NaCl](http://nacl.cr.yp.to/), a cryptographic library. Includes both\nin-browser and node.js support.\n\nThe paper \"[The security impact of a new cryptographic\nlibrary](http://cr.yp.to/highspeed/coolnacl-20120725.pdf)\" is an\nexcellent summary of the motivation behind the NaCl API and library\ndesign.\n\nUsing this library in the browser requires support for the newish\n`window.crypto.getRandomValues` API.\n\n**WARNING**: This code will not run in Safari version 5.1.x; or, at\nleast, will not run when Safari's Javascript debug mode is *disabled*.\nSymptoms include corruption during hash calculation, failures when\nunboxing, and failures when producing and verifying signatures. Safari\n7.0 seems to be just fine, however. I don't know exactly at which\nversion Safari started working: I don't have access to enough of a\nrange of systems. The code has run fine on Chrome and Firefox across\nall the versions I've tried.\n\n## Changes\n\nVersion 0.5.0: **API change.** Instead of being provided with a module\n`nacl`, with API functions available directly, library importers are\ngiven `nacl_factory` with a single function `instantiate`, which\nreturns a `nacl` instance containing the API functions.\n\n## NPM Package\n\nThis library is [registered on\nnpmjs.org](https://npmjs.org/package/js-nacl). To install it:\n\n    npm install js-nacl\n\n## Building the library\n\nThe git checkout includes a pre-compiled version of the library, so\nyou won't need Emscripten unless you want to change something about\nthe underlying NaCl library itself.\n\nEssentially, the source checkout contains everything you will need to\nuse the library in both the browser and in node.js.\n\nIf you do find yourself wanting to build the library, see the\ninstructions in\n[BUILDING.md](https://github.com/tonyg/js-nacl/blob/master/BUILDING.md).\n\n## Using the library\n\nIn the browser, include the `lib/nacl_factory.js` script:\n\n    <script src=\"lib/nacl_factory.js\"></script>\n    ...\n    <script>\n      var nacl = nacl_factory.instantiate();\n      alert(nacl.to_hex(nacl.random_bytes(16)));\n    </script>\n\nIn node.js, require the `lib/nacl_factory.js` module:\n\n    var nacl_factory = require(\"./lib/nacl_factory.js\");\n    var nacl = nacl_factory.instantiate();\n    ...\n    console.log(nacl.to_hex(nacl.random_bytes(16)));\n\nOr if you have installed the library via `npm`,\n\n    var nacl_factory = require(\"js-nacl\");\n    var nacl = nacl_factory.instantiate();\n    ...\n    console.log(nacl.to_hex(nacl.random_bytes(16)));\n\n## Instantiating the NaCl module\n\nCalling `nacl_factory.instantiate()` creates an entirely fresh module\ninstance, complete with its own private heap area. By default, this\nheap is 32 megabytes in size, 33,554,432 bytes. The size of the module\ninstance's private heap can be altered by supplying an argument to\n`instantiate`, e.g.:\n\n    var nacl = nacl_factory.instantiate(16777216);\n\nThe argument must be a power of two, if supplied.\n\nIt's fine to instantiate the module more than once in a single\nprogram, though do note the large amount of memory taken up by each\ninstance. The memory assigned to each module instance will not be\nreleased until the instance is garbage collected.\n\nIf you notice memory leaks across multiple uses of a *single* module\ninstance, please report them, with a test case if at all possible.\n\n## Strings vs. Binary Data\n\nThe library enforces a strict distinction between strings and binary\ndata. Binary data is represented using instances of\n[`Uint8Array`](https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays/Uint8Array).\n\n### nacl.to_hex(Uint8Array) → String\n\nReturns a lower-case hexadecimal representation of the given binary\ndata.\n\n### nacl.from_hex(String) → Uint8Array\n\nConverts a lower- or upper-case hexadecimal representation of binary\ndata into the equivalent Uint8Array.\n\n### nacl.encode_utf8(String) → Uint8Array\n\nReturns the binary equivalent of the argument, encoded using UTF-8.\n\n### nacl.encode_latin1(String) → Uint8Array\n\nReturns the binary equivalent of the argument, encoded using Latin1\n(an 8-bit clean encoding). If any of the character codes in the\nargument string are greater than 255, an exception is thrown.\n\n### nacl.decode_utf8(Uint8Array) → String\n\nDecodes the binary data in the argument using the UTF-8 encoding,\nproducing the corresponding string.\n\n### nacl.decode_latin1(Uint8Array) → String\n\nDecodes the binary data in the argument using the Latin1 8-bit clean\nencoding, producing the corresponding string.\n\n## Hashing: crypto_hash\n\nFollows the [NaCl crypto_hash API](http://nacl.cr.yp.to/hash.html).\n\n### nacl.crypto\\_hash(Uint8Array) → Uint8Array\n\nComputes the SHA-512 hash of its argument.\n\nWhile SHA-512 is recommended, the SHA-256 function is also available,\nas `nacl.crypto\\_hash\\_sha256`.\n\n### nacl.crypto\\_hash\\_string(String) → Uint8Array\n\nEncodes its argument using `nacl.encode_utf8`, and then calls\n`crypto_hash`.\n\n## Public-key authenticated encryption: crypto_box\n\nFollows the [NaCl crypto_box API](http://nacl.cr.yp.to/box.html).\n\nYou do not need to perform any padding of any arguments to these\nfunctions; the API given here is most similar to the \"C++\" API in the\nNaCl documentation.\n\n**Make sure to follow the instructions regarding nonce selection given\nin the \"Security model\" section of the NaCl API documentation!**\n\n    senderKeypair = nacl.crypto_box_keypair();\n    recipientKeypair = nacl.crypto_box_keypair();\n    message = nacl.encode_utf8(\"Hello!\");\n\n    nonce = nacl.crypto_box_random_nonce();\n    packet = nacl.crypto_box(message, nonce, recipientKeypair.boxPk, senderKeypair.boxSk);\n\n    decoded = nacl.crypto_box_open(packet, nonce, senderKeypair.boxPk, recipientKeypair.boxSk);\n\n    \"Hello!\" === nacl.decode_utf8(decoded); // always true\n\n### nacl.crypto\\_box\\_keypair() → {\"boxPk\": Uint8Array, \"boxSk\": Uint8Array}\n\nCreates a fresh random keypair. `boxPk` is the public key and `boxSk`\nis the secret key.\n\n### nacl.crypto\\_box\\_random\\_nonce() → Uint8Array\n\nReturns a fresh randomly-chosen nonce suitable for use with\n`crypto_box`.\n\n### nacl.crypto\\_box(msgBin, nonceBin, recipientPublicKeyBin, senderSecretKeyBin) → Uint8Array\n\nPlaces `msg` in an authenticated, encrypted box that can only be\nverified and decrypted by the secret key corresponding to\n`recipientPublicKey`.\n\n### nacl.crypto\\_box\\_open(ciphertextBin, nonceBin, senderPublicKeyBin, recipientSecretKeyBin) → Uint8Array\n\nVerifies and decrypts a box from `crypto_box`. Throws an exception if\nthe verification fails or any of the inputs are invalid.\n\n### nacl.crypto\\_box\\_precompute(publicKeyBin, secretKeyBin) → {\"boxK\": Uint8Array}\n\nPrecomputes a shared secret between two parties. See the documentation\nfor `crypto_box_beforenm` at the NaCl website.\n\n### nacl.crypto\\_box\\_precomputed(msgBin, nonceBin, {\"boxK\": Uint8Array}) → Uint8Array<br>nacl.crypto\\_box\\_open\\_precomputed(ciphertextBin, nonceBin, {\"boxK\": Uint8Array}) → Uint8Array\n\nPrecomputed-secret variants of `crypto_box` and `crypto_box_open`.\n\n## Secret-key authenticated encryption: crypto_secretbox\n\nFollows the [NaCl crypto_secretbox API](http://nacl.cr.yp.to/secretbox.html).\n\nYou do not need to perform any padding of any arguments to these\nfunctions; the API given here is most similar to the \"C++\" API in the\nNaCl documentation.\n\n**Make sure to follow the instructions regarding nonce selection given\nin the \"Security model\" section of the NaCl API documentation!**\n\n    k = ...;\n    m = nacl.encode_utf8(\"message\");\n    n = nacl.crypto_secretbox_random_nonce();\n    c = nacl.crypto_secretbox(m, n, k);\n    m1 = nacl.crypto_secretbox_open(c, n, k);\n    \"message\" === nacl.decode_utf8(m1); // always true\n\n### nacl.crypto\\_secretbox\\_random\\_nonce() → Uint8Array\n\nReturns a fresh randomly-chosen nonce suitable for use with\n`crypto_secretbox`.\n\n### nacl.crypto\\_secretbox(msgBin, nonceBin, keyBin) → Uint8Array\n\nPlaces `msg` in an authenticated, encrypted box that can only be\nverified and decrypted by someone who knows `keyBin`. The `keyBin`\nUint8Array must be `nacl.crypto_secretbox_KEYBYTES` bytes long.\n\n### nacl.crypto\\_secretbox\\_open(ciphertextBin, nonceBin, keyBin) → Uint8Array\n\nVerifies and decrypts a packet from `crypto_secretbox`. Throws an\nexception if the verification fails or any of the inputs are invalid.\n\n## Secret-key encryption: crypto_stream\n\nFollows the [NaCl crypto_stream API](http://nacl.cr.yp.to/stream.html).\n\n**Make sure to follow the instructions regarding nonce selection given\nin the \"Security model\" section of the NaCl API documentation!**\n\nSince this style of secret-key encryption is symmetric,\n`nacl.crypto_stream_xor` is suitable for decryption as well as\nencryption:\n\n    k = ...;\n    m = nacl.encode_utf8(\"message\");\n    n = nacl.crypto_stream_random_nonce();\n    c = nacl.crypto_stream_xor(m, n, k);\n    m1 = nacl.crypto_stream_xor(c, n, k);\n    \"message\" === nacl.decode_utf8(m1); // always true\n\n### nacl.crypto\\_stream\\_random\\_nonce() → Uint8Array\n\nReturns a fresh randomly-chosen nonce suitable for use with\n`crypto_stream`.\n\n### nacl.crypto\\_stream(lenInt, nonceBin, keyBin) → Uint8Array\n\nReturns a `lenInt`-byte length keystream based on the given nonce and\nkey. The key must be `nacl.crypto_stream_KEYBYTES` bytes long.\n\n### nacl.crypto\\_stream\\_xor(msgBin, nonceBin, keyBin) → Uint8Array\n\nReturns `msgBin.length` bytes of ciphertext (or plaintext, depending\non the contents of `msgBin`) produced by XORing `msgBin` with the\nresult of `nacl.crypto_stream(msgBin.length, nonceBin, keyBin)`.\n\n## Secret-key single-message authentication: crypto_onetimeauth\n\nFollows the [NaCl crypto_onetimeauth API](http://nacl.cr.yp.to/onetimeauth.html).\n\n## Secret-key message authentication: crypto_auth\n\nFollows the [NaCl crypto_auth API](http://nacl.cr.yp.to/auth.html).\n\n## Signatures: crypto_sign\n\nFollows the [NaCl crypto_sign API](http://nacl.cr.yp.to/sign.html).\n\nNote that this uses the version of [Ed25519](http://ed25519.cr.yp.to/)\nfrom [SUPERCOP](http://bench.cr.yp.to/supercop.html), and *not* the\nold prototype implementation from the nacl 20110221 release.\n\nThe SUPERCOP Ed25519 signature scheme used is compatible with\nlibsodium and most other bindings and wrappers of libsodium and nacl.\n\n### nacl.crypto\\_sign\\_keypair() → {\"signPk\": Uint8Array, \"signSk\": Uint8Array}\n\nCreates a fresh random keypair. `signPk` is the public key and\n`signSk` is the secret key.\n\n    k = nacl.crypto_sign_keypair();\n    m = nacl.encode_utf8(\"message\");\n    signed_m = nacl.crypto_sign(m, k.signSk);\n    m1 = nacl.crypto_sign_open(signed_m, k.signPk);\n    \"message\" === nacl.decode_utf8(m1); // always true\n\n### nacl.crypto\\_sign(msgBin, signerSecretKey) → Uint8Array\n\nProduces a signature-wrapped version of `msgBin`.\n\n### nacl.crypto\\_sign\\_open(packetBin, signerPublicKey) → (Uint8Array || null)\n\nVerifies the signature on the given `packetBin`, and if it is valid,\nextracts the carried message and returns it. If the signature could\nnot be verified, returns `null`.\n\n### nacl.crypto\\_sign\\_detached(msgBin, signerSecretKey) → Uint8Array\n\n**WARNING: Experimental.** Produces a \"detached\" signature that,\nunlike `crypto_sign`, excludes the actual message body. The result can\nbe used with `crypto_sign_verify_detached`.\n\nThe returned detached signature will be `nacl.crypto_sign_BYTES` in\nlength.\n\n### nacl.crypto\\_sign\\_verify\\_detached(detachedSignatureBin, msgBin, signerPublicKey) → (true || false)\n\n**WARNING: Experimental.** Given a \"detached\" signature from\n`crypto_sign_detached`, along with the original message and the\nsigner's public signing key, returns `true` if the signature is valid,\nand `false` otherwise.\n\n## Derived Keys\n\n**WARNING: Experimental**\n\nIf you see yourself wanting to use these, you will need to know why\n[PBKDF2](http://en.wikipedia.org/wiki/PBKDF2) and\n[scrypt](http://www.tarsnap.com/scrypt.html) are of crucial\nimportance.\n\nYou might like to explore the use of these functions in tandem with\n`scrypt.crypto_scrypt` from\n[js-scrypt](https://github.com/tonyg/js-scrypt).\n\nIt is not generally safe to supply (for example) a user's passphrase\ndirectly to these procedures without using PBKDF2, scrypt or something\nsimilar beforehand.\n\n### nacl.crypto\\_sign\\_keypair\\_from\\_seed(Uint8Array) → {\"signPk\": Uint8Array, \"signSk\": Uint8Array}\n\nProduces a *signing* keypair from its argument. A given binary input\nwill always produce the same keypair as output.\n\nThe input must be 32 bytes long. As\n[Brian Warner puts it](https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/),\n\"Ed25519 keys start life as a 32-byte (256-bit) uniformly random\nbinary seed\" such as might be produced by sha256, or better yet,\nPBKDF2 or scrypt.\n\nMake sure to read and understand the warnings relating to passpharses,\nPBKDF2 and scrypt at the beginning of this section.\n\nCompatible with [PyNaCl](https://github.com/warner/pynacl)'s\n`crypto_sign_keypair_fromseed` and\n[racl](https://github.com/tonyg/racl)'s `bytes->crypto-sign-keypair`.\n\n### nacl.crypto\\_box\\_keypair\\_from\\_seed(Uint8Array) → {\"boxPk\": Uint8Array, \"boxSk\": Uint8Array}\n\nProduces an *encrypted authenticated box* keypair from its argument. A\ngiven binary input will always produce the same keypair as output.\n\nThe input may be of any length. The input is hashed once with sha512,\nand the first 32 bytes of the result are taken as the 32-byte secret\nkey, which is then passed to `nacl.crypto_box_keypair_from_raw_sk`.\n\nMake sure to read and understand the warnings relating to passpharses,\nPBKDF2 and scrypt at the beginning of this section.\n\nCompatible with [racl](https://github.com/tonyg/racl)'s\n`bytes->crypto-box-keypair`.\n\n### nacl.crypto\\_box\\_keypair\\_from\\_raw\\_sk(Uint8Array) → {\"boxPk\": Uint8Array, \"boxSk\": Uint8Array}\n\nProduces an *encrypted authenticated box* keypair from its argument. A\ngiven binary input will always produce the same keypair as output.\n\nThe input must be 32 bytes long, and could be a random 32-byte value,\nor the output of sha256, or better yet, the output of PBKDF2 or\nscrypt.\n\nMake sure to read and understand the warnings relating to passpharses,\nPBKDF2 and scrypt at the beginning of this section.\n\nCompatible with [racl](https://github.com/tonyg/racl)'s\n`crypto-box-sk->pk`.\n\n## Low-level tools\n\n### nacl.crypto\\_scalarmult(Uint8Array, Uint8Array) → Uint8Array\n\nExpects two binaries, the first of length\n`nacl.crypto_scalarmult_SCALARBYTES` (representing an integer), and\nthe second of length `nacl.crypto_scalarmult_BYTES` (representing a\ngroup element). The two are multiplied using the underlying NaCl\n`crypto_scalarmult` primitive, and the resulting\n`nacl.crypto_scalarmult_BYTES`-length group element binary is\nreturned.\n\n### nacl.crypto\\_scalarmult\\_base(Uint8Array) → Uint8Array\n\nAs `nacl.crypto_scalarmult`, but multiplies the\n`nacl.crypto_scalarmult_SCALARBYTES`-length argument by a standard\ngroup element, returning the result.\n\n## License\n\njs-nacl is written by Tony Garnock-Jones <tonygarnockjones@gmail.com>\nand is licensed under the [MIT\nlicense](http://opensource.org/licenses/MIT):\n\n> Copyright &copy; 2013 Tony Garnock-Jones.\n>\n> Permission is hereby granted, free of charge, to any person\n> obtaining a copy of this software and associated documentation files\n> (the \"Software\"), to deal in the Software without restriction,\n> including without limitation the rights to use, copy, modify, merge,\n> publish, distribute, sublicense, and/or sell copies of the Software,\n> and to permit persons to whom the Software is furnished to do so,\n> subject to the following conditions:\n>\n> The above copyright notice and this permission notice shall be\n> included in all copies or substantial portions of the Software.\n>\n> THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n> EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n> MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n> NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n> BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n> ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n> CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n> SOFTWARE.\n\njs-nacl relies on NaCl itself, which is public domain code by Daniel\nJ. Bernstein and others.\n\njs-nacl's build process relies on (a modified version of) the\n`import.py` script by Brian Warner, which comes from\n[PyNaCl](https://github.com/warner/pynacl) and is licensed under\n[version 2.0 of the Apache\nlicense](http://www.apache.org/licenses/LICENSE-2.0.html).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/tonyg/js-nacl/issues"
  },
  "_id": "js-nacl@0.6.0",
  "dist": {
    "shasum": "fcbca8a0b88875735195e2814c3199215ce91050"
  },
  "_from": "js-nacl@",
  "_resolved": "https://registry.npmjs.org/js-nacl/-/js-nacl-0.6.0.tgz"
}
